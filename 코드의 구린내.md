# 코드의 구린내
### 목록
- 중복코드
- 장황한 메서드
- 방대한 클래스
- 과다한 매개변수
- 수정의 산발
- 기능의 산재
- 잘못된 소속
- 데이터 뭉치
- 강박적 기본 타입 사용
- switch 문
- 평행 상속 계층
- 직무유기 클래스
- 막연한 범용 코드
- 임시 필드
- 메시지 체인
- 과잉 중개 메서드
- 지나친 관여
- 인터페이스가 다른 대용 클래스
- 미흡한 라이브러리 클래스
- 데이터 클래스
- 방치된 상속물
- 불필요한 주석

#### 중복코드

구린내의 제왕. 똑같은 코드 구조가 두 군데 이상 있을 때는 하나로 통일하면 프로그램이 개선된다.

```
예)
- 한 클래스의 두 메서드 안에 같은 코드가 들어 있는 경우.
==> [메서드 추출]기법 적용

- 한 클래스의 두 하위 클래스에 같은 코드가 들어 있는 경우.
==> [메서드 추출]기법 적용 후 [메서드 상향]기법 적용

- 코드가 똑같지 않고 비슷하다면 경우에 따라 [템플릿 메서드]기법 적용.

- 두 메서드가 알고리즘만 다르고 기능이 같다면 두 알고리즘 중 더 간단한 것을 택해서 [알고리즘 전환]기법을 적용.

- 중복 코드가 메서드 가운데에 있다면 [주변 메서드 추출]을 적용.

- 서로 상관없는 두 클래스 안에 중복 코드가 있을 때는 [클래스 추출]이나 [모듈 추출]을 적용. 제 삼의 클래스나 모듈로 떼어내거나 두 클래스 중 하나에 넣고 다른 클래스에서 호출하도록 한다.

```



#### 장황한 메서드

최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드 길이가 **짧다**. 현대의 객체지향 언어는 프로세스 내부 호출에 따른 오버헤드가 현저히 적다. 

대신 하위 프로시저의 기능을 알려면 환경을 전환해야 하므로 코드를 보고 이해하려는 사람의 머릿속에 오버헤드가 생기게 됐다. 

짧은 메서드를 이해하기 쉽게 하려면 메서드명을 잘 정해야 한다. 메서드의 기능을 한눈에 알 수 있는 메서드 명을 사용하면 그 메서드 안의 코드를 분석하지 않아도 된다.

이를 위해서는 **메서드를 훨씬 과감하게 쪼개야 한다**. 주석을 달아야할 것 같은 부분에 주석을 넣는 대신 메서드를 작성한다. 그 메서드 명은 기능 수행 방식이 아니라 **목적, 기능 자체를 나타내는 이름으로 정한다.** 이 방법은 코드가 한 줄짜리든 여러 줄짜리든 상관없이 적용할 수 있다. 원래 코드보다 길어지는 한이 있어도, 메서드명은 그 코드의 의도를 잘 반영하는 것으로 정해야 한다.

```
메서드를 줄이려면 십중팔구는 [메서드 추출]기법을 적용해야 한다. 하나로 묶으면 좋을 만한 부분들을 찾아내어 메서드로 만드는 것이다.

메서드에 매개변수나 임시변수가 많으면 [메서드 추출]을 실시하기가 까다롭다. 수많은 매개변수와 임시변수를 새로 만든 메서드의 매개변수로 넘기면 가독성에서 원래의 코드와 별 다를게 없어진다.

웬만한 경우에는 임시변수를 [메서드 호출로 전환]기법이나 [메서드 체인으로 전환]기법을 적용해 제거하자. 길게 열거된 매개변수는 [매개변수 세트를 객체로 전환]기법과 [객체를 통째로 전달]기법을 적용하면 간결해진다.

이런 리팩토링 기법을 적용했어도 여전히 임시변수와 매개 변수가 너무 많을 때는 [메서드를 메서드 객체로 전환]기법을 적용하면 된다.

조건문과 루프도 역시 메서드로 빼야 한다. 조건문을 추출하려면 [조건문 쪼개기]기법을 사용해야 한다. [루프를 컬렉션 클로저 메서드로 전환]을 실시한 후, 그 클로저 메서드 호출과 클로저 자체에 [메서드 추출]을 실시하면 된다.
```



#### 방대한 클래스

#### 과다한 매개변수

#### 수정의 산발

#### 기능의 산재

#### 잘못된 소속

#### 데이터 뭉치

#### 강박적 기본 타입 사용

#### switch 문

#### 평행 상속 계층

#### 직무유기 클래스

#### 막연한 범용 코드

#### 임시 필드

#### 메시지 체인

#### 과잉 중개 메서드

#### 지나친 관여

#### 인터페이스가 다른 대용 클래스

#### 미흡한 라이브러리 클래스

#### 데이터 클래스

#### 방치된 상속물

#### 불필요한 주석
