# Studying Design Patterns with [Head First Design Patterns]

## 객체지향 원칙
- 바뀌는 부분은 캡슐화한다.
- 상속보다는 구성을 활용한다.
- 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
- 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.

## 스트래티지 패턴(strategy pattern)
- 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다.
- 스트래티지를 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.
- ex) com.exam.strategy.simuduck.model.Duck은 자신의 행동알고리즘을 교환해서 사용할 수 있도록
  알고리즘군인 behavior 인터페이스를 사용한다.(composition)

## 옵저버 패턴(observer pattern)
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로
일대다(one-to-many) 의존성을 정의합니다.
  
## 데코레이터 패턴(decorator pattern)
- 객체에 추가 요소를 동적으로 더할 수 있다. 데코레이터를 사용하면 서브클래스를 만드는 경우에 비해 훨씬 유언하게 기능을 확장할 수 있다.

#### 핵심정리
- 상속을 통해 확장을 할 수도 있지만, 디자인의 유연성 면에서 별로 좋지 않습니다.
- 기존 코드를 수정하지 않고도 행동을 확장하는 방법이 필요합니다.
- 구성과 위임을 통해서 실행중에 새로운 행동을 추가할 수 있습니다.
- 상속 대신 데코레이터 패턴을 통해서 행동을 확장할 수 있습니다.
- 데코레이터 패턴에서는 구상 구성요소를 감싸주는 데코레이터들을 사용합니다.
- 데코레이터 클래스의 형식은 그 클래스가 감싸고 있는 클래스의 형식을 반영합니다.(상속 또는 인터페이스 구현을 통해서 자신이 감쌀 클래스와 같은 형식을 가지게 됩니다)
- 데코레이터에서는 자기가 감싸고 있는 구성요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장합니다.
- 구성요소를 감싸는 데코레이터의 개수에는 제한이 없습니다.
- 구성요소의 클라이언트 입장에서는 데코레이터의 존재를 알 수 없습니다.
  - 클라이언트에서 구성요소의 구체적인 형식에 의존하게 되는 경우에는 적합하지 않다.  
- 데코레이터 패턴을 사용하면 자잘한 객체들이 매우 많이 추가될 수 있고, 데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해질 수도 있습니다.

## 팩토리 패턴
- 모든 팩토리 패턴에서는 객체 생성을 캡슐화합니다.
- 팩토리 메소드 패턴에서는 서브클래스에서 어떤 클래스를 만들지를 결정하게 함으로써 객체 생성을 캡슐화합니다.
- 추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있습니다. 클라이언트에서
추상 인터페이스를 통해서 일련의 제품들을 공급받을 수 있습니다.
```
팩토리 메소드 vs 추상 팩토리
1 . 팩토리 메소드
  - 서브 클래스를 통해서 객체생성.
  - 클라이언트 코드와 인스턴스를 만들어야 할 구상 클래스를 분리시켜야 할 때 사용.
  - 어떤 구상 클래스를 필요로 하게 될지 미리 알 수 없는 경우에도 매우 유용. 

2. 추상 팩토리
  - 객체 구성(composition)을 사용. '제품군'을 만들기 위한 추상 형식을 제공. 제품 생산 방법은 서브 클래스에서 정의.
    객체 생성이 팩토리 인터페이스에서 선언한 메소드들에서 구현됨.
  - 클라이언트에서 서로 연관된 일련의 제품들을 만들어야 할 때, 즉 제품군을 만들어야 할 때 활용.

공통점 
- 클라이언트와 클라이언트에서 사용하는 실제 구상 제품을 분리시켜 줌. => 객체 생성을 캡슐화해서 애플리케이션의 결합을 느슨하게 만들고,
  특정 구현에 덜 의존하도록 만듦.
``` 

# 디자인 원칙
## OCP(Open-Closed Principle)
- 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.
## Dependency Inversion Principle
- 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하지 않도록 한다.
- 가이드 라인
  - 어떤 변수에도 구상 클래스에 대한 레퍼런스를 저장하지 않는다.
  - 구상 클래스에서 유도된 클래스를 만들지 않는다.
  - 베이스 클래스에 이미 구현되어 있던 메소드를 오버라이드하지 않는다. => 이미 구현되어 있는 메소드를 오버라이드한다는 것은 애초부터 베이스 클래스가 제대로 추상화된 것이 아니었다고 볼 수 있습니다.