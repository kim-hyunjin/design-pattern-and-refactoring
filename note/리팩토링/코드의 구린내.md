# 코드의 구린내

### 목록

- 중복코드
- 장황한 메서드
- 방대한 클래스
- 과다한 매개변수
- 수정의 산발
- 기능의 산재
- 잘못된 소속
- 데이터 뭉치
- 강박적 기본 타입 사용
- switch 문
- 평행 상속 계층
- 직무유기 클래스
- 막연한 범용 코드
- 임시 필드
- 메시지 체인
- 과잉 중개 메서드
- 지나친 관여
- 인터페이스가 다른 대용 클래스
- 미흡한 라이브러리 클래스
- 데이터 클래스
- 방치된 상속물
- 불필요한 주석

#### 중복코드

구린내의 제왕. 똑같은 코드 구조가 두 군데 이상 있을 때는 하나로 통일하면 프로그램이 개선된다.

```
예)
- 한 클래스의 두 메서드 안에 같은 코드가 들어 있는 경우.
==> [메서드 추출]기법 적용

- 한 클래스의 두 하위 클래스에 같은 코드가 들어 있는 경우.
==> [메서드 추출]기법 적용 후 [메서드 상향]기법 적용

- 코드가 똑같지 않고 비슷하다면 경우에 따라 [템플릿 메서드]기법 적용.

- 두 메서드가 알고리즘만 다르고 기능이 같다면 두 알고리즘 중 더 간단한 것을 택해서 [알고리즘 전환]기법을 적용.

- 중복 코드가 메서드 가운데에 있다면 [주변 메서드 추출]을 적용.

- 서로 상관없는 두 클래스 안에 중복 코드가 있을 때는 [클래스 추출]이나 [모듈 추출]을 적용. 
  제 삼의 클래스나 모듈로 떼어내거나 두 클래스 중 하나에 넣고 다른 클래스에서 호출하도록 한다.

```



#### 장황한 메서드

최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드 길이가 **짧다**. 현대의 객체지향 언어는 프로세스 내부 호출에 따른 오버헤드가 현저히 적다. 

대신 하위 프로시저의 기능을 알려면 환경을 전환해야 하므로 코드를 보고 이해하려는 사람의 머릿속에 오버헤드가 생기게 됐다. 

짧은 메서드를 이해하기 쉽게 하려면 메서드명을 잘 정해야 한다. 메서드의 기능을 한눈에 알 수 있는 메서드 명을 사용하면 그 메서드 안의 코드를 분석하지 않아도 된다.

이를 위해서는 **메서드를 훨씬 과감하게 쪼개야 한다**. 주석을 달아야할 것 같은 부분에 주석을 넣는 대신 메서드를 작성한다. 그 메서드 명은 기능 수행 방식이 아니라 **목적, 기능 자체를 나타내는 이름으로 정한다.** 이 방법은 코드가 한 줄짜리든 여러 줄짜리든 상관없이 적용할 수 있다. 원래 코드보다 길어지는 한이 있어도, 메서드명은 그 코드의 의도를 잘 반영하는 것으로 정해야 한다.

```
메서드를 줄이려면 십중팔구는 [메서드 추출]기법을 적용해야 한다. 하나로 묶으면 좋을 만한 부분들을 찾아내어 메서드로 만드는 것이다.

메서드에 매개변수나 임시변수가 많으면 [메서드 추출]을 실시하기가 까다롭다. 
수많은 매개변수와 임시변수를 새로 만든 메서드의 매개변수로 넘기면 가독성에서 원래의 코드와 별 다를게 없어진다.

웬만한 경우에는 임시변수를 [메서드 호출로 전환]기법이나 [메서드 체인으로 전환]기법을 적용해 제거하자. 
길게 열거된 매개변수는 [매개변수 세트를 객체로 전환]기법과 [객체를 통째로 전달]기법을 적용하면 간결해진다.

이런 리팩토링 기법을 적용했어도 여전히 임시변수와 매개 변수가 너무 많을 때는 [메서드를 메서드 객체로 전환]기법을 적용하면 된다.

조건문과 루프도 역시 메서드로 빼야 한다. 조건문을 추출하려면 [조건문 쪼개기]기법을 사용해야 한다. 
[루프를 컬렉션 클로저 메서드로 전환]을 실시한 후, 그 클로저 메서드 호출과 클로저 자체에 [메서드 추출]을 실시하면 된다.
```



#### 방대한 클래스

기능이 지나치게 많은 클래스에는 보통 엄청난 수의 인스턴스 변수가 들어 있다. 클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련이다.

```
[클래스 추출]을 실시하면 수많은 인스턴스 변수를 하나로 묶을 수 있다.
서로 연관된 변수를 골라서 클래스로 빼내면 된다.

하위 클래스로 추출하는 것이 적합할 것 같으면 [하위클래스 추출]을 실시하는 것이 더 간단하다.
만약 추출할 클래스가 대리자로 부적절할 것 같으면 [모듈 추출]을 실시하면 된다.

코드 분량이 너무 방대한 클래스에 대해서 위의 방법 외에
클라이언트가 그 클래스를 어떻게 사용할지 결정하게 하고, 사용 방법마다 [인터페이스 추출]을 실시하는 방법도 있다.

방대한 클래스가 GUI 클래스라면 데이터와 기능을 서로 다른 도메인 객체로 옮겨야 할 수도 있다.
이를 위해 일부 중복 데이터는 놔두고 그 데이터와 싱크를 유지해야 할 수도 있다. 이것은 [관측 데이터 복제]기법을 실시하면 된다.
```



#### 과다한 매개변수

매개변수 세트가 간결하다는 것은 장점이다. 매개변수 세트가 길면 서로 일관성이 없어지거나 사용이 불편해지고, 더 많은 데이터가 필요할 때마다 계속 수정해야 하기 때문에 그 매개변수들을 이해하기가 힘들다.

```
이미 알고 있는 객체에 요청하여 데이터를 가져올 수 있을 때는 [매개변수 세트를 메서드로 전환]을 적용하면 된다.
[객체를 통째로 전달], [매개변수 세트를 객체로 전환]등의 방법도 있다.

호출되는 객체가 호출 객체에 의존하면 안 될 때는 예외다. 
이럴 때는 데이터를 개별적으로 빼서 매개변수로 전달하는 것이 바람직하지만, 어려움이 따른다. 
나열된 매개변수 세트가 너무 길거나 자주 바뀐다면 불가피하게 종속 구조를 유지하는 것도 생각해봐야 한다.
```



#### 수정의 산발

수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 일어난다. 각 객체는 한 종류의 수정에 의해서만 변경되는 것이 좋다. 

```
수정의 산발이 발생하는 경우(금융 상품을 추가할 때마다 4개의 메서드를 수정해야 하는 등), 
특정 원인으로 변하는 모든 부분을 찾은 후 [클래스 추출]을 적용해서 그 부분들을 합쳐 한 클래스로 빼내야 한다.
```



#### 기능의 산재

기능의 산재는 수정의 산발과 비슷하지만 정 반대다. 수정할 때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 한다면 이 문제를 의심할 수 있다. 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 꼭 수정해야 하는 부분을 놓치기 쉽다.

```
이럴 때는 [메서드 이동]과 [필드 이동]을 적용해 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다. 
기존의 클래스 중 어느 것에 넣기도 부적절해 보일 때는 새 클래스를 만들어야 한다.
대개는 [클래스 내용 직접 삽입]을 적용해서 별도 클래스에 분산되어 있던 모든 기능을 한 곳으로 가져와도 된다. 
<수정의 산발> 문제가 조금 생기지만, 간단히 처리할 수 있다.

<수정의 산발>은 한 클래스에 여러 수정이 발생하는 문제이고, <기능의 산재>는 하나의 수정으로 여러 클래스가 바뀌게 되는 문제다. 
둘 중 어느 것이든 수정과 클래스가 일대일 대응되게 깔끔히 정리해야 한다.
```



#### 잘못된 소속

객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술이라는 점이다.

전통적으로 어떤 메서드가 자신이 속하지 않은 클래스에 더 많이 접근한다면 <잘못된 소속>의 구린내가 풍길 것이다. 

```
잘못 소속된 메서드가 흔히 접근하는 대상은 데이터다.
소속이 잘못된 메서드는 더 많이 접근하는 클래스에 들어가는 것이 마땅하니, 
[메서드 이동]기법을 실시해 더 자주 접근하는 클래스로 옮겨야 한다. 

메서드의 일부만이 소속이 잘못된 경우, [메서드 추출]을 적용 후 [메서드 이동]을 적용해서 적절한 클래스로 옮기면 된다.

한 메서드가 여러 클래스에 들어 있는 기능을 이용할 때도 많은데, 
이때는 문제의 메서드가 접근하는 데이터가 어느 클래스에 제일 많이 들어 있는지 파악해서 그 클래스로 옮긴다. 
그러기 전에 [메서드 추출]을 실시해 그 메서드를 다른 클래스에 들어갈 여러 부분으로 쪼개면 작업이 더 쉬워진다.
```

이 규칙을 따르지 않는 복잡한 패턴도 있다. GOF의 디자인 패턴 중 [전략 패턴]과 [방문자 패턴], 켄트 백의 저서에 수록된 [자가 위임 패턴]이 그렇다. 

#### 데이터 뭉치

#### 강박적 기본 타입 사용

#### switch 문

#### 평행 상속 계층

#### 직무유기 클래스

#### 막연한 범용 코드

#### 임시 필드

#### 메시지 체인

#### 과잉 중개 메서드

#### 지나친 관여

#### 인터페이스가 다른 대용 클래스

#### 미흡한 라이브러리 클래스

#### 데이터 클래스

#### 방치된 상속물

#### 불필요한 주석
